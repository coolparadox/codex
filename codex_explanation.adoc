== Codex Explanation

"`Explanation`" here means to take the (asciidoc) output from <<Codex Expansion>>
and produce:

. Asciidoc output with _codex_ blocks replaced by content suited for printing;
. Instructions for generating code files in filesystem (to be processed by <<Codex Extrusion>>).

This is the heavy lifting of _codex_ processing,
and is performed by *codexplain* tool.

////
//codexplain.cpp
/cpp preamble

/codexplain includes

/codexplain defines
/codexplain declarations

int main(int argc, char* argv[])
{
    /codexplain main
}
////

_Codexplain_ is designed as a stream processor:

* input is read from file descriptor 0;
* explained asciidoc is sent to file descriptor 1;
* error messages are sent to file descriptor 2;
* extrusion commands are sent to file descriptor 3.

////
///reset
/main declarations
////

////
/codexplain main
/main declarations
if (argc != 1)
{
    /show codexplain usage
    return 1;
}
////

////
/codexplain includes
#include <iostream>
////

////
/show codexplain usage
std::cerr << "usage: codexplain 0<expansion 1>explanation 3>extrusion" << std::endl;
////

Let's keep file descriptor 3 open for writing;
accessible by C stream _ext_ (after "`extrusion`").

////
codexplain includes
#include <cstdio>
////

////
/main declarations
FILE* ext;
////

////
/codexplain main
ext = fdopen(3, "w");
if (!ext)
{
    std::cerr << "error: cannot open file descriptor 3 for writing." << std::endl;
    return 1;
}
////


=== Overall Strategy 

_Codex_ features like
definition of chunks after they are referenced (see <<Code Chunks>>)
and generation of total counts for continued chunks (see <<Chunk Continuation>>)
require parsing of all input prior to generation of output.

Let's define variable _document_ as the keeper of all parsed content.

////
/main declarations
Document document;
////

////
/codexplain declarations

struct Document;
/codexplain support types

struct Document
{
    /Document fields
};
////

The overall strategy is then:
first, parse all input into _document_.

////
///reset
/read 'line' from input
/parse 'line'
/handle end of input
////

////
/codexplain main
while (std::cin.good())
{
    /read 'line' from input
    /parse 'line'
}
/handle end of input
////

////
/codexplain includes
#include <string>
////

////
/read 'line' from input
std::string line;
std::getline(std::cin, line);
if (!std::cin.good()) break;
////

////
/handle end of input
if (!std::cin.eof())
{
    std::cerr << "codexplain: error: cannot read standard input" << std::endl;
    return 1;
}
////

Second, produce output from _document_ contents.

////
/codexplain main
/sanity check 'document'
/initialize output
/for each 'element' of 'document'
{
    /explain 'element'
    /if 'element' is a code file
    {
        /extrude 'element'
    }
}
////

And we're done.

////
/codexplain main
return 0;
////

==== Recognition of Comment Blocks

As codex blocks are special asciidoc comment blocks delimited by `////`,
let's detect these delimiters and keep track of comment block boundaries.

////
/main declarations
bool inside_comment_block { false };
////

////
/codexplain defines
#define COMMENT_BLOCK_DELIMITER "////"
////

////
/parse 'line'
if (!inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    /acquire 'line' as asciidoc content
}
else if (!inside_comment_block && line == COMMENT_BLOCK_DELIMITER)
{
    inside_comment_block = true;
    /start comment block acquisition
}
else if (inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    /acquire 'line' as comment block content
}
else
{
    inside_comment_block = false;
    /end comment block acquisition
}
////

=== Codex Elements

_CodexElement_ abstract class is the base class for parsed elements.

////
/codexplain support types
/CodexElement support types

class CodexElement
{
 public:
    /CodexElement methods
};
////

////
/codexplain includes
#include <vector>
////

////
/Document fields
std::vector<CodexElement*> elements;
////

////
/for each 'element' of 'document'
for (CodexElement* element: document.elements)
////

Method _explain_ of _CodexElement_ outputs printable content about itself
to file descriptor 1.
This method receives the parsed document for eventual queries.

////
/CodexElement methods
virtual void explain(const Document* document) = 0;
////

////
/explain 'element'
element->explain(&document);
////

Method _extrude_ of _CodexElement_ outputs file generation instructions
to file descriptor 3.
Likewise, this method receives the parsed document for eventual queries.

////
/CodexElement methods
virtual void extrude(const Document* document, ExtrusionParameters parameters) = 0;
////

////
/extrude 'element'
element->extrude(&document, {});
////

////
/CodexElement support types

struct ExtrusionParameters
{
    /ExtrusionParameters fields
};
////

References to chunks may contain indentation that affects all referenced content
when producing code files (see example in <<Code Chunks>>).

////
/ExtrusionParameters fields
std::string prefix;
////

They also tell if the referenced chunk must attach itself to the previous and/or
next lines (see <<Line Break Escape>>).

////
/ExtrusionParameters fields
bool break_line_before { true };
bool break_line_after { true };
////

==== Asciidoc Line

Representation of a line of asciidoc raw input.

////
/codexplain support types

class AsciidocLine : public CodexElement
{
 public:
    /AsciidocLine constructor
    /AsciidocLine explain override
    /extrude empty override
 private:
    /AsciidocLine fields
};
////

_AsciidocLine_ holds a single line of raw asciidoc input.

////
/AsciidocLine fields
std::string line_;
////

////
/AsciidocLine constructor
explicit AsciidocLine(const std::string& line)
        : line_(line)
{
}
////

////
/acquire 'line' as asciidoc content
document.elements.push_back(new AsciidocLine(line));
////

Explanation of raw asciidoc is straightforward -- just copy to output.

////
/AsciidocLine explain override
/introduce explain method override
{
    std::cout << line_ << std::endl;
}
////

////
/introduce explain method override
virtual void explain(const Document* document) override
////

Extrusion of raw asciidoc is nonsense.

////
/extrude empty override
/introduce extrude method override
{
}
////

////
/introduce extrude method override
virtual void extrude(const Document* document, ExtrusionParameters parameters) override
////

==== Comment Block

_CommentBlock_ represents an asciidoc comment block delimited by `////`.

////
/codexplain support types

class CommentBlock : public CodexElement
{
 public:
    /CommentBlock constructor
    /CommentBlock explain override
    /extrude empty override
 private:
    /CommentBlock fields
};
////

_CommentBlock_ stores all lines inside the represented comment block.

////
/CommentBlock fields
std::vector<std::string> lines_;
////

////
/CommentBlock constructor
explicit CommentBlock(const std::vector<std::string>& lines)
        : lines_(lines)
{
}
////

////
/main declarations
std::vector<std::string> comment_lines;
////

////
/start comment block acquisition
comment_lines.clear();
////

////
/acquire 'line' as comment block content
comment_lines.push_back(line);
////

All other types of codex elements are particular types of comment blocks.

////
/end comment block acquisition
parse_comment_block(document, comment_lines);
////

////
/codexplain declarations
void parse_comment_block(Document& document, const std::vector<std::string> lines);
////

////
//codexplain.cpp

void parse_comment_block(Document& document, const std::vector<std::string> lines)
{
    /parse comment block
    document.elements.push_back(new CommentBlock(lines));
}
////

Comment blocks are explained by themselves.

////
/CommentBlock explain override
/introduce explain method override
{
    std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
    for (std::string line: lines_)
    {
        std::cout << line << std::endl;
    }
    std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
}
////

==== Code Chunks

Code chunks are comment blocks where the first content line starts with a single `/`.

////
/parse comment block
if (lines.size() >= 2 && lines[0].size() >= 2 && lines[0][0] == '/' && lines[0][1] != '/')
{
    /parse code chunk
    return;
}
////

////
/codexplain support types

/CodeChunk support types

class CodeChunk : public CodexElement
{
 public:
    /CodeChunk constructor
    /CodeChunk methods
 private:
    /CodeChunk fields
};
////

Each chunk block of a document is uniquely identified by a name, a form number and a part number.
Also, a chunk holds pieces of content suitable to extrusion and explanation.

////
/parse code chunk
std::string name;
int form_number;
int part_number;
std::vector<CodexElement*> content;
/acquire code chunk constructor parameters
document.elements.push_back(new CodeChunk(name, form_number, part_number, content));
////

////
/CodeChunk constructor
CodeChunk(std::string name, int form_number, int part_number, std::vector<CodexElement*> content)
{
    /CodeChunk constructor body
}
////

The chunk name is provided by the first line of a codex comment block without the heading `/`.

////
/acquire code chunk constructor parameters
name = lines[0].substr(1);
////

////
/CodeChunk fields
std::string name_;
////

////
/CodeChunk constructor body
name_ = name;
if (name_.empty() || name_[0] == '/')
{
    throw std::runtime_error(std::string("invalid chunk name '") + name_ + "'");
}
////

The form number for a given chunk name
starts at 1 and is increment by <<Chunk Reset>> directive.

////
/codexplain includes
#include <unordered_map>
////

////
/Document fields
std::unordered_map<std::string, int> form_counts;
////

////
/acquire code chunk constructor parameters
form_number = document.form_counts.insert(std::make_pair<std::string, int>(std::string(name), 1)).first->second;
////

////
/CodeChunk fields
int form_number_;
////

////
/codexplain includes
#include <cassert>
////

////
/CodeChunk constructor body
form_number_ = form_number;
assert(form_number_ >= 1);
////

The part number for a given chunk name and form number starts at 1
and is incremented on each occurrence of chunks with same name in input.

////
/codexplain includes
#include <tuple>
////

////
/Document fields
std::unordered_map<std::tuple<std::string, int>, int> part_counts;
////

////
/codexplain support types

/enable use of tuple<string,int> as map keys
////

////
/acquire code chunk constructor parameters
part_number = ++document.part_counts.insert(std::make_pair<std::tuple<std::string, int>, int>(std::make_tuple(name, form_number), 0)).first->second;
////

////
/CodeChunk fields
int part_number_;
////

////
/CodeChunk constructor body
part_number_ = part_number;
assert(part_number_ >= 1);
////

A chunk comprises lines of literal source code intermixed with references to other chunks.

////
/acquire code chunk constructor parameters
for (auto line = lines.cbegin() + 1; line != lines.cend(); ++line)
{
    /is 'line' a chunk reference?
    {
        /append chunk reference to 'content'
        continue;
    }
    /correct for chunk reference escape
    /append literal code line to 'content'
}
////

////
/CodeChunk fields
std::vector<CodexElement*> content_;
////

////
/CodeChunk constructor body
content_ = content;
assert(!content_.empty());
////

////
/CodeChunk methods
/introduce explain method override
{
    for (CodexElement* element: content_)
    {
        element->explain(document);
    }
}
////

////
/CodeChunk methods
/introduce extrude method override
{
    for (CodexElement* element: content_)
    {
        element->extrude(document, parameters);
    }
}
////

===== Chunk References

Chunk references start with a single `/`, optionally prefixed by blanks.

////
/is 'line' a chunk reference?
str::string line_tmp(*line);
std::string prefix;
for (auto ch = line_tmp->cbegin(); ch != line_tmp->cend(); ++ch)
{
    if (*ch != ' ' && *ch != '\t') break;
    prefix.push_back(*ch);
}
line_tmp->erase(0, prefix.len());
if (line_tmp.size() >= 2 && line_tmp.at(0) == '/' && line_tmp.at(1) != '/')
////

////
/append chunk reference to 'content'
line_tmp->erase(0, 1);
/extract line break escape flags from 'line'
content.push_back(new ChunkReference(line_tmp, prefix, pre_escape, pos_escape));
////

Chunk references may specify line break escapes; see <<Line Break Escape>>;

////
/extract line break escape flags from 'line'
bool pre_escape { false };
bool pos_escape { false };
if (line_tmp.size() >= 3 && line_tmp.at(line_tmp.size() - 3) == '/')
{
    char pre_ch = line_tmp.at(line_tmp.size() - 2);
    char pos_char = line_tmp.at(line_tmp.size() - 1);
    if ((pre_ch == '.' || pre_ch == '+') && (pos_ch == '.' || pos_ch == '+'))
    {
        pre_escape = pre_ch == '+';
        pos_escape = pos_ch == '+';
        line_tmp.erase(line_tmp.size() - 3);
    }
}
////

...

////
/codexplain support types

class ChunkReference : public CodexElement
{
 public:
    /ChunkReference constructor
    /ChunkReference methods
 private:
    /ChunkReference fields
};
////



...

////
/ChunkReference methods
/introduce explain method override
{
    ...
}
////

////
/ChunkReference methods
/introduce extrude method override
{
    ...
}
////

Chunk references remember their indentation.

...

...

=== Miscellaneous

Tuples require custom hash generators to be used as keys in C++ unordered maps.

////
/enable use of tuple<string,int> as map keys
namespace std
{
    template<> struct hash<std::tuple<std::string, int>>
    {
        std::size_t operator()(std::tuple<std::string, int>const& s) const noexcept
        {
            std::string s1;
            int s2;
            std::tie(s1, s2) = s;
            return std::hash<std::string>{}(std::to_string(s2) + "\0" + s1);
        }
    };
}
////
