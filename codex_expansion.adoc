== Codex Expansion

This section implements recursive expansion of <<Codex Include>> directives in an
asciidoc document.

This is performed by *codexpand* tool.

////
//codexpand.cpp
/cpp preamble

/codexpand includes

/codexpand defines

/codexpand declarations

int main(int argc, char* argv[])
{
    /codexpand main
}
////

_codexpand_ expects the path to an asciidoc file as its only argument.

////
/codexpand main
if (argc != 2)
{
    /show codexpand usage
    return 1;
}
////

////
/codexpand includes
#include <iostream>
////

////
/show codexpand usage
std::cerr << "usage: codexpand <file>" << std::endl;
////

The gist of codexpand is the _expand_ function,
that receives the path to an asciidoc file
as parameter _path_,
and the stack of called paths as parameter _paths_.

////
/codexpand includes
#include <string>
#include <vector>
////

////
/codexpand declarations
int expand(std::string path, std::vector<std::string> paths);
////

////
/codexpand main
return expand(argv[1], {});
////

////
//codexpand.cpp

int expand(std::string path, std::vector<std::string> paths)
{
    /codexpand expand
    return 0;
}
////

_expand_ is designed to be recursive and assumes the path stack represents
the current depth level of the expansion.
This offers an opportunity to detect expansion loops.

////
/codexpand includes
#include <algorithm>
////

////
/codexpand expand
if (std::find(paths.cbegin(), paths.cend(), path) != paths.cend())
{
    std::cerr << "codexpand: error: inclusion loop detected: " << path << std::endl;
    return 1;
}
////

Let's access each line of input.

////
/codexpand includes
#include <fstream>
////

////
///reset
/setup stream 'fin' for reading file 'path'
/read 'line' from 'fin'
/expand 'line'
/handle 'fin' termination
////

////
/codexpand expand
/expand declarations
/setup stream 'fin' for reading file 'path'
while (fin.good())
{
    /read 'line' from 'fin'
    /expand 'line'
}
/handle 'fin' termination
////

////
/setup stream 'fin' for reading file 'path'
std::ifstream fin;
fin.open(path, std::ifstream::in);
////

////
/read 'line' from 'fin'
std::string line;
std::getline(fin, line);
if (!fin.good()) break;
////

////
/handle 'fin' termination
if (!fin.eof())
{
    std::cerr << "codexpand: error: cannot read '" << path << "'" << std::endl;
    return 1;
}
////

Codex include blocks are comment blocks delimited by `////`;
let's detect these delimiters and keep track of comment block boundaries.

////
/expand declarations
bool inside_comment_block { false };
////

////
/codexpand defines
#define COMMENT_BLOCK_DELIMITER "////"
////

////
///reset
/start comment block expansion
/append line to comment block expansion
/end comment block expansion
////

////
/expand 'line'
if (!inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    std::cout << line << std::endl;
    continue;
}
else if (!inside_comment_block && line == COMMENT_BLOCK_DELIMITER)
{
    inside_comment_block = true;
    /start comment block expansion
}
else if (inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    /append line to comment block expansion
}
else
{
    inside_comment_block = false;
    /end comment block expansion
}
////

Comment blocks are acquired separately, so they can be tested for
codex include blocks.

////
/expand declarations
std::vector<std::string> comment_block;
////

////
/start comment block expansion
comment_block.clear();
////

////
/append line to comment block expansion
comment_block.push_back(line);
////

////
///reset
/is comment block a codex include?
/replace block by inclusion of new file
/copy block to output

////

////
/end comment block expansion
/is comment block a codex include?
{
    /replace block by inclusion of new file
    continue;
}
/copy block to output
////

If a comment block is a codex include directive,
recurse for including contents of the new file.

////
/is comment block a codex include?
if (comment_block.size() == 2 && comment_block[0] == "///include")
////

////
/replace block by inclusion of new file
std::vector<std::string> new_paths { paths };
new_paths.push_back(path);
int rcode { expand(comment_block[1], new_paths) };
if (rcode != 0) return rcode;
////

Otherwise just dump the comment block.

////
/copy block to output
std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
for (auto it {comment_block.cbegin()}; it != comment_block.cend(); ++it )
{
    std::cout << *it << std::endl;
}
std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
////
