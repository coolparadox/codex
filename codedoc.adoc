= Codedoc
Rafael Lorandi <coolparadox@gmail.com>
:doctype: book
:sectnums:
:toc: left
:source-highlighter: coderay
:revnumber: 0.0
:revdate: 09-08-2018
:revremark: Scratching phase

Codedoc is a literate programming tool for asciidoc documentation format.

The literate programming paradigm enforces indirection layers on top of computer source code
in order to support expression of its logic in ways more suited to human thinking
instead of machine demanded order.

Asciidoc is a plain text, human readable document format, semantically equivalent to DocBook,
but using lightweight markup conventions.
Asciidoc files can be read as is or converted to HTML, DocBook, PDF and other formats.

[colophon]
= Colophon

Version: {revnumber}

Version Date: {revdate}

Version Notes: {revremark}

Codedoc is a literate programming tool for asciidoc documentation format. +
Copyright (C) 2018 Rafael Lorandi

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

[preface]
= Preface

By mid 2018, a search for literate programming for asciidoc leaded exclusively to
https://sourceforge.net/projects/eweb/[eWEB - literate programming in AsciiDoc] by Filippo Negroni.
eWEB 9.10 (current version at the time) offers _etangle.py_,
a tangler that recognizes code chunks embedded in asciidoc listing blocks.
Since input files to the tangler are already asciidoc compliant documents,
no weaver is deemed to be necessary.

eWEB served as a source of inspiration for Codedoc.

= User Guide

== Introduction

Codedoc is a preprocessor for asciidoc documentation
that recognizes asciidoc comment blocks containing predefined content as pieces of source code.
Codedoc is designed to serve as a tool for literate programming.

This is more easily explained by examples.

=== Code File Blocks

Say the following appears anywhere in an asciidoc document:

....
////
//hello.c
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
////
....

Note that the first content line starts with `//`
followed by a file name 
(in this case file hello.c in a flat directory,
but you can name files under subdirectories as well).
Further lines of the block contain the source code of hello.c.

If you process the asciidoc document directly,
the above block is ignored as `////` delimits a comment block in asciidoc syntax.
Running *codedoc* instead over the asciidoc document however produces two outcomes:

. A processed version of the asciidoc document that renders this block as:
+
.hello.c
[#hello_c_1]
++++
<div id="hello_c_1" class="exampleblock" style="margin-bottom:1.25em;">
<div class="title">hello.c</div>
<div class="content" style="margin-bottom:.5em;">
<code style="background-color:unset;">#include &lt;stdio.h&gt;</code><br>
<code style="background-color:unset;">int main() {</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;printf("Hello world!\n");</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;return 0;</code><br>
<code style="background-color:unset;">}</code><br>
</div>
</div>
++++
+
This block is named by anchor _#hello_c_1_,
allowing references from anywhere in the processed document: <<hello_c_1>>

. File _hello.c_ in filesystem containing:
+
....
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
....

Code file blocks therefore allow the documentation of a software project
to be the primary source of its source code.

=== Code Chunk Blocks

If you're new to literate programming, at this point you may be wondering
what is the benefit of bringing whole source files to the realm of a document only to
extract them in a preprocessing step afterwards.

Things get more interesting when chunks of code are introduced.
As the name implies, code chunk blocks are simply named fragments of source code. Examples:

....
////
/hello includes
#include <stdio.h>
////
....

....
////
/hello main
int main() {
    printf("Hello world!\n");
    return 0;
}
////
....

The first content line of each comment block is the chunk name
(the leading `/` is obligatory for enablement of codedoc processing over the comment block).
Given these chunks, _hello.c_ can then be defined as the following source code block:

....
////
//hello.c
/hello includes
/hello main
////
....

Now codedoc generates a processed version of the asciidoc document
that renders these blocks as:

.hello includes
[[hello-includes]]
[source,c]
----
#include <stdio.h>
----

.hello main
[[hello-main]]
[source,c]
----
int main() {
    printf("Hello world!\n");
    return 0;
}
----

.hello.c
====
_<<<<hello-includes>>>>_ +
_<<<<hello-main>>>>_
====


Note the //...

chhubks are recursive
any order in file


=== Chunk Continuation

...

== Installation

Great gobs of mud...

[glossary]
== Part 1 Glossary

[glossary]
mud:: wet, cold dirt

= Part 2

[preface]
== Part 2 Preface

This part was written because...

== Chapter 1

The mud had turned to cement...

The hail-and-rainbow protocol can be initiated at five levels: double, tertiary, supernumerary, supermassive, and apocalyptic party.footnote:[The double hail-and-rainbow level makes my toes tingle.]   
A bold statement!footnoteref:[disclaimer,Opinions are my own.]   

Another outrageous statement.footnoteref:[disclaimer] 

:sectnums!:
[appendix]
include::license.adoc[]
