== Codex Explanation

"`Explanation`" here means to take the (asciidoc) output from <<Codex Expansion>>
and produce:

. Asciidoc output with _codex_ blocks replaced by content suited for printing;
. Instructions for generating code files in filesystem (to be processed by <<Codex Extrusion>>).

This is the heavy lifting of _codex_ processing,
and is performed by *codexplain* tool.

////
//codexplain.cpp
/cpp preamble

/codexplain includes

/codexplain defines
/codexplain declarations

int main(int argc, char* argv[])
{
    /codexplain main
}
////

_Codexplain_ is designed as a stream processor:

* input is read from file descriptor 0;
* explained asciidoc is sent to file descriptor 1;
* error messages are sent to file descriptor 2;
* extrusion commands are sent to file descriptor 3.

////
///reset
/main declarations
////

////
/codexplain main
/main declarations
if (argc != 1)
{
    /show codexplain usage
    return 1;
}
////

////
/show codexplain usage
std::cerr << "usage: codexplain 0<expansion 1>explaination 3>extrusion" << std::endl;
////

////
/codexplain includes
#include <iostream>
////

Let's keep file descriptor 3 open for writing;
accessible by C stream _ext_ (after "`extrusion`").

////
/main declarations
FILE* ext;
////

////
/codexplain main
ext = fdopen(3, "w");
if (!ext)
{
    std::cerr << "error: cannot open file descriptor 3 for writing." << std::endl;
    return 1;
}
////

////
codexplain includes
#include <cstdio>
////


=== Overall Strategy 

_Codex_ features like
definition of chunks after they are referenced (see <<Code Chunks>>)
and generation of total counts for continued chunks (see <<Chunk Continuation>>)
require parsing of all input prior to generation of output.

Let's define variable _document_ as the keeper of all parsed content.

////
/main declarations
Document document;
////

////
/codexplain declarations

struct Document;
/codexplain support types

struct Document
{
    /Document fields
};
////

The overall strategy is then:
first, parse all input into _document_.

////
///reset
/read 'line' from input
/parse 'line'
/handle end of input
////

////
/codexplain main
while (std::cin.good())
{
    /read 'line' from input
    /parse 'line'
}
/handle end of input
////

////
/read 'line' from input
std::string line;
std::getline(std::cin, line);
if (!std::cin.good()) break;
////

////
/handle end of input
if (!std::cin.eof())
{
    std::cerr << "codexplain: error: cannot read standard input" << std::endl;
    return 1;
}
////

////
/codexplain includes
#include <string>
////

Second, produce output from _document_ contents.

////
/codexplain main
/sanity check 'document'
/for each 'element' of 'document'
{
    /explain 'element'
    /if 'element' is a code file
    {
        /extrude 'element'
    }
}
////

And we're done.

////
/codexplain main
return 0;
////

==== Recognition of Comment Blocks

As codex blocks are special asciidoc comment blocks delimited by `////`,
let's detect these delimiters and keep track of comment block boundaries.

////
/main declarations
bool inside_comment_block { false };
////

////
/codexplain defines
#define COMMENT_BLOCK_DELIMITER "////"
////

////
/parse 'line'
if (!inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    /acquire 'line' as asciidoc content
}
else if (!inside_comment_block && line == COMMENT_BLOCK_DELIMITER)
{
    inside_comment_block = true;
    /start comment block acquisition
}
else if (inside_comment_block && line != COMMENT_BLOCK_DELIMITER)
{
    /acquire 'line' as comment block content
}
else
{
    inside_comment_block = false;
    /end comment block acquisition
}
////

=== Codex Elements

_CodexElement_ abstract class is the base class for parsed elements.

////
/codexplain support types
/CodexElement support types

class CodexElement
{
 public:
    /CodexElement methods
};
////

////
/Document fields
std::vector<CodexElement*> elements;
////

////
/codexplain includes
#include <vector>
////

////
/for each 'element' of 'document'
for (CodexElement* element: document.elements)
////

Method _explain_ of _CodexElement_ outputs printable content about itself
to file descriptor 1.
This method receives the parsed document for eventual queries.

////
/CodexElement methods
virtual void explain(const Document* document) = 0;
////

////
/explain 'element'
element->explain(&document);
////

Method _extrude_ of _CodexElement_ outputs file generation instructions
to file descriptor 3.
Likewise, this method receives the parsed document for eventual queries.

////
/CodexElement methods
virtual void extrude(const Document* document, ExtrusionParameters parameters) = 0;
////

////
/extrude 'element'
element->extrude(&document, {});
////

////
/CodexElement support types

struct ExtrusionParameters
{
    /ExtrusionParameters fields
};
////

References to chunks may contain indentation that affects all referenced content
when producing code files (see example in <<Code Chunks>>).

////
/ExtrusionParameters fields
std::string prefix;
////

They also tell if the referenced chunk must attach itself to the previous and/or
next lines (see <<Line Break Escape>>).

////
/ExtrusionParameters fields
bool break_line_before { true };
bool break_line_after { true };
////

==== Asciidoc Line

Representation of a line of asciidoc raw input.

////
/codexplain support types

class AsciidocLine : public CodexElement
{
 public:
    /AsciidocLine constructor
    /AsciidocLine explain override
    /AsciidocLine extrude override
 private:
    /AsciidocLine fields
};
////

_AsciidocLine_ holds a single line of raw asciidoc input.

////
/AsciidocLine fields
std::string line_;
////

////
/AsciidocLine constructor
explicit AsciidocLine(const std::string& line)
        : line_(line)
{
}
////

////
/acquire 'line' as asciidoc content
document.elements.push_back(new AsciidocLine(line));
////

Explanation of raw asciidoc is straightforward -- just copy to output.

////
/AsciidocLine explain override
/introduce explain method override
{
    std::cout << line_ << std::endl;
}
////

////
/introduce explain method override
virtual void explain(const Document* document) override
////

Extrusion of raw asciidoc is nonsense.

////
/AsciidocLine extrude override
/introduce extrude method override
{
}
////

////
/introduce extrude method override
virtual void extrude(const Document* document, ExtrusionParameters parameters) override
////

==== Comment Block

_CommentBlock_ represents an asciidoc comment block delimited by `////`.

////
/codexplain support types

class CommentBlock : public CodexElement
{
 public:
    /CommentBlock constructor
    /CommentBlock explain override
    /CommentBlock extrude override
 private:
    /CommentBlock fields
};
////

_CommentBlock_ stores all lines inside the represented comment block.

////
/CommentBlock fields
std::vector<std::string> lines_;
////

////
/CommentBlock constructor
explicit CommentBlock(const std::vector<std::string>& lines)
        : lines_(lines)
{
}
////

////
/main declarations
std::vector<std::string> comment_lines;
////

////
/start comment block acquisition
comment_lines.clear();
////

////
/acquire 'line' as comment block content
comment_lines.push_back(line);
////

Other types of codex elements may be disguised as comment blocks.

////
/end comment block acquisition
parse_comment_block(document, comment_lines);
////

////
/codexplain declarations
void parse_comment_block(Document& document, const std::vector<std::string> lines);
////

////
//codexplain.cpp

void parse_comment_block(Document& document, const std::vector<std::string> lines)
{
    /parse comment block
    document.elements.push_back(new CommentBlock(lines));
}
////

Comment blocks are explained by themselves.

////
/CommentBlock explain override
/introduce explain method override
{
    std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
    for (std::string line: lines_)
    {
        std::cout << line << std::endl;
    }
    std::cout << COMMENT_BLOCK_DELIMITER << std::endl;
}
////

Extrusion of comment blocks is nonsense.

////
/CommentBlock extrude override
/introduce extrude method override
{
}
////

