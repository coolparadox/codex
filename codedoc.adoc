= Codedoc
Rafael Lorandi <coolparadox@gmail.com>
:doctype: book
:sectnums:
:toc: left
:source-highlighter: coderay
:revnumber: 0.0
:revdate: 09-08-2018
:revremark: Scratching phase

Codedoc is a literate programming tool for asciidoc documentation format.

The literate programming paradigm enforces indirection layers on top of computer source code
in order to support expression of its logic in ways more suited to human thinking
instead of machine demanded order.

Asciidoc is a plain text, human readable document format, semantically equivalent to DocBook,
but using lightweight markup conventions.
Asciidoc files can be read as is or converted to HTML, DocBook, PDF and other formats.

[colophon]
= Colophon

Version: {revnumber}

Version Date: {revdate}

Version Notes: {revremark}

Codedoc is a literate programming tool for asciidoc documentation format. +
Copyright (C) 2018 Rafael Lorandi

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

[preface]
= Preface

By mid 2018, a search for literate programming for asciidoc leaded exclusively to
https://sourceforge.net/projects/eweb/[eWEB - literate programming in AsciiDoc] by Filippo Negroni.
eWEB 9.10 (current version at the time) offers _etangle.py_,
a tangler that recognizes code chunks embedded in asciidoc listing blocks.
Since input files to the tangler are already asciidoc compliant documents,
no weaver is deemed to be necessary.

eWEB served as a source of inspiration for Codedoc.

= User Guide

== Codedoc by Examples

Codedoc is a preprocessor for asciidoc documentation
that recognizes asciidoc comment blocks containing predefined content as pieces of source code.
Codedoc is designed to serve as a tool for literate programming.

This is more easily explained by examples.

=== Code File Blocks

Say the following appears anywhere in an asciidoc document:

....
////
//hello.c
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
////
....

Note that the first content line starts with `//`
followed by a file name 
(in this case file hello.c in a flat directory,
but you can name files under subdirectories as well).
Further lines of the block contain the source code of hello.c.

If you process the asciidoc document directly,
the above block is ignored as `////` delimits a comment block in asciidoc syntax.
Running *codedoc* instead over the asciidoc document however produces two outcomes:

. A processed version of the asciidoc document that renders this block as:
+
.hello.c
[#hello_c_1]
++++
<div id="hello_c_1" class="exampleblock" style="margin-bottom:1.25em;">
<div class="title">hello.c</div>
<div class="content" style="margin-bottom:.5em;">
<code style="background-color:unset;">#include &lt;stdio.h&gt;</code><br>
<code style="background-color:unset;">int main() {</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;printf("Hello world!\n");</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;return 0;</code><br>
<code style="background-color:unset;">}</code><br>
</div>
</div>
++++
+
This block is named by anchor _#hello_c_1_,
allowing references from anywhere in the processed document: <<hello_c_1>>

. File _hello.c_ in filesystem containing:
+
....
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
....

Code file blocks therefore allow the documentation of a software project
to be the primary source of its source code.

=== Code Chunk Blocks

If you're new to literate programming, at this point you may be wondering
what is the benefit of bringing whole source files to the realm of a document only to
extract them in a preprocessing step afterwards.

Things get more interesting when chunks of code are introduced.
As the name implies, code chunk blocks are named fragments of source code. Examples:

....
////
/hello includes
#include <stdio.h>
////
....

....
////
/hello main
int main() {
    printf("Hello world!\n");
    return 0;
}
////
....

Codedoc understands a comment block
whose first content line contains a single leading `/`
as a code chunk.

Given the above chunks anywhere in the document,
_hello.c_ could then be defined as the following code file block:

....
////
//hello.c
/hello includes
/hello main
////
....

As you see, code file hello.c references code chunks.
Now *codedoc* generates a processed version of the asciidoc document
that renders these blocks as:

.hello includes
[#hello_includes_1]
++++
<div id="hello_includes_1" class="exampleblock" style="margin-bottom:1.25em;">
<div class="title">hello includes</div>
<div class="content" style="margin-bottom:.5em;">
<code style="background-color:unset;">#include &lt;stdio.h&gt;</code><br>
</div>
<div class="title"><sup>
Used by: <a href="#hello_c_2">hello.c</a>.
</sup></div>
</div>
++++

.hello main
[#hello_main_1]
++++
<div id="hello_main_1" class="exampleblock" style="margin-bottom:1.25em;">
<div class="title">hello main</div>
<div class="content" style="margin-bottom:.5em;">
<code style="background-color:unset;">int main() {</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;printf("Hello world!\n");</code><br>
<code style="background-color:unset;">&nbsp;&nbsp;&nbsp;&nbsp;return 0;</code><br>
<code style="background-color:unset;">}</code><br>
</div>
<div class="title"><sup>
Used by: <a href="#hello_c_2">hello.c</a>.
</sup></div>
</div>
++++

.hello.c
[#hello_c_2]
++++
<div id="hello_c_2" class="exampleblock" style="margin-bottom:1.25em;">
<div class="title">hello.c</div>
<div class="content" style="margin-bottom:.5em;">
<em><a href="#hello_includes_1">hello includes</a></em><br>
<em><a href="#hello_main_1">hello main</a></em><br>
</div>
</div>
++++

(This simple example does not require it,
but code chunks can also reference other code chunks.)

Same as before, file _hello.c_ is generated in filesystem
containing the result of recursively de-referencing its chunk references:

....
#include <stdio.h>
int main() {
    printf("Hello world!\n");
    return 0;
}
....

There is no requirement as to
the order by which chunk and code blocks are defined within the document --
you are free to reference chunks defined later in the document as well,
if you decide it suits better the explanation flow of your documentation.

Code chunks support a powerful concept in literate programming, namely that
software programs should be considered works of literature.
Therefore you cannot properly document software if you are restricted
to the realm of machine understandable entities like functions and methods,
as they don't usually capture optimally
how the ideas behind the source code were formed.

[quote, Donald Knuth, Introducer of the literate programming paradigm]
Instead of imagining that our main task is to instruct a computer what to do,
let us concentrate rather on explaining to human beings what we want a computer to do.

=== Chunk Continuation

...

== Installation

Great gobs of mud...

[glossary]
== Part 1 Glossary

[glossary]
mud:: wet, cold dirt

= Part 2

[preface]
== Part 2 Preface

This part was written because...

== Chapter 1

The mud had turned to cement...

The hail-and-rainbow protocol can be initiated at five levels: double, tertiary, supernumerary, supermassive, and apocalyptic party.footnote:[The double hail-and-rainbow level makes my toes tingle.]   
A bold statement!footnoteref:[disclaimer,Opinions are my own.]   

Another outrageous statement.footnoteref:[disclaimer] 

:sectnums!:
[appendix]
include::license.adoc[]
